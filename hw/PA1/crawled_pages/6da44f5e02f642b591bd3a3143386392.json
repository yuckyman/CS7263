{
  "url": "http://nlp.stanford.edu/IR-book/html/htmledition/faster-postings-list-intersection-via-skip-pointers-1.html",
  "title": "Faster postings list intersection via skip pointers",
  "body": "\n\n\n\n\nFaster postings list intersection via skip pointers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: Positional postings and phrase\n Up: The term vocabulary and\n Previous: Stemming and lemmatization\n    Contents \n    Index\n\n\n\n\n \n\nFaster postings list intersection via skip pointers\n\n\nIn the remainder of this chapter, we will discuss extensions to postings\nlist data structures and ways to increase the efficiency of using postings\nlists.\nRecall the basic postings list intersection operation from \nSection 1.3 (page ): we walk through the two postings lists\nsimultaneously, in time linear in the total number of postings entries.\nIf the list lengths are  and , the intersection takes \noperations.  Can we do better than this?  That is, empirically, can we usually\nprocess postings list intersection in sublinear time?  We can, if the index isn't\nchanging too fast.\n\n\nOne way to do this is to use a  skip list  by augmenting postings\nlists with skip pointers (at \nindexing time), as shown in Figure 2.9 .  Skip pointers are\neffectively shortcuts that allow us to avoid processing parts of\nthe postings list that will not figure in the search results.  The two\nquestions are then where to place skip pointers and how to do efficient\nmerging using skip pointers.\n\n\n\n\n\n\n\nPostings lists with skip pointers.The postings intersection can\n  use a skip pointer when the end point is still less than the item on\n  the other list.\n\n\n\n\n\nFigure 2.10:\nPostings lists intersection with skip pointers.\n\n\n\n\nConsider first efficient merging, with Figure 2.9  as an\nexample.  Suppose we've stepped through the lists in the figure until\nwe have matched  on each list and moved it to the results\nlist.  We advance both pointers, giving us  on the upper\nlist and  on the lower list.  The smallest item is then\nthe element  on the top list. Rather than simply\nadvancing the upper pointer, we first check the skip list pointer and\nnote that 28 is also less than 41.  Hence we can follow the skip list\npointer, and then we advance the upper pointer to .\nWe thus avoid stepping to  and \non the upper list.  A number of variant versions of postings list\nintersection with skip pointers is possible depending on when exactly\nyou check the skip pointer.  One version is shown in\nFigure 2.10 .  Skip pointers\nwill only be available for the original postings lists.  For an\nintermediate result in a complex query, the call\n\n will always return false.  Finally, note\nthat the presence of skip pointers only helps for AND queries,\nnot for OR queries.\n\n\nWhere do we place skips?  There is a tradeoff.  \nMore skips means shorter skip spans, and that we are more likely to\nskip.  But it also means lots of comparisons to skip pointers, and lots\nof space storing skip pointers.\nFewer skips means few pointer comparisons, but then long skip spans\nwhich means that there will be fewer opportunities to skip.\nA simple heuristic for placing skips, which has been found to work well\nin practice, is that for a postings list of length , use  \nevenly-spaced skip pointers.\nThis heuristic can be improved upon; it ignores any details\nof the\ndistribution of query terms. \n\n\nBuilding effective skip pointers is easy if an index is relatively\nstatic; it is harder if a postings list keeps changing because of\nupdates. A malicious deletion strategy can render skip lists\nineffective. \n\n\nChoosing the optimal encoding for an inverted index is an ever-changing\ngame for the system builder, because it is strongly dependent on underlying computer\ntechnologies and their relative speeds and sizes.\nTraditionally, CPUs were slow, and so highly compressed techniques were\nnot optimal.  Now CPUs are fast and disk is slow, so reducing disk\npostings list size dominates. However, if you're running a search\nengine with everything in memory then the equation changes again.  \nWe discuss the impact of hardware parameters on index construction time\nin Section 4.1 (page ) and the impact of index size on system speed\nin Chapter 5 .\n\n\nExercises.\n\nWhy are skip pointers not useful for queries of the form  OR ?\n\n\n\nWe have a two-word query. For one term the postings list consists of\nthe following 16 entries:\n\n[4,6,10,12,14,16,18,20,22,32,47,81,120,122,157,180]\n\n\nand for the other it is the one entry postings list:\n\n[47].\n\n\nWork out how many comparisons would be done to \nintersect the two postings lists with the following\ntwo strategies. Briefly justify your answers: \n\n\nUsing standard postings lists\n\nUsing postings lists stored with skip pointers, with a skip \nlength of , as \nsuggested in Section 2.3 .\n\n\n\n\nConsider a postings intersection between this postings list, with skip pointers:\n\nxunit=0.6cm,arcangle=30\n\n\n\n\nand the following intermediate result postings list (which hence has no skip pointers): \n\n3    5    89    95    97    99    100    101\n\n\nTrace through the postings intersection algorithm in Figure 2.10 (page ).\n\n\nHow often is a skip pointer followed (i.e.,  is advanced to \n)?\n\nHow many postings comparisons will be made by this algorithm while intersecting the two lists?\n\nHow many postings comparisons would be made if the postings lists are intersected without the use of skip pointers?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: Positional postings and phrase\n Up: The term vocabulary and\n Previous: Stemming and lemmatization\n    Contents \n    Index\n\n\n© 2008 Cambridge University PressThis is an automatically generated page. In case of formatting errors you may want to look at the PDF edition of the book.\n2009-04-07\n\n\n\n"
}