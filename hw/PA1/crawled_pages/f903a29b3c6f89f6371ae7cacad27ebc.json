{
  "url": "http://nlp.stanford.edu/IR-book/html/htmledition/crawler-architecture-1.html",
  "title": "Crawler architecture",
  "body": "\n\n\n\n\nCrawler architecture\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: Distributing the crawler\n Up: Crawling\n Previous: Crawling\n    Contents \n    Index\n\n\n\n\n \n\nCrawler architecture\n\n\nThe simple scheme outlined above for crawling demands several\nmodules that fit together as shown in Figure 20.1 .\n\n\nThe URL frontier, containing URLs yet to be fetched in the\ncurrent crawl (in the case of continuous crawling, a URL may have\nbeen fetched previously but is back in the frontier for\nre-fetching). We describe this further in Section 20.2.3 .\n\nA DNS resolution module that determines the web\nserver from which to fetch the page specified by a URL. We describe this\nfurther in Section 20.2.2 .\n\nA fetch module that uses the http protocol to retrieve the web page at a URL.\n\nA parsing module that extracts the text and set of links from a\nfetched web page.\n\nA duplicate elimination module that determines whether an extracted link is\nalready in the URL frontier or has recently been fetched.\n\n\n\n\n\nFigure 20.1:\nThe basic crawler architecture.\n\n\n\n\nCrawling is performed by anywhere from one to potentially\nhundreds of threads, each of which loops through the logical cycle\nin Figure 20.1 . These threads may be run in a single\nprocess, or be partitioned amongst multiple processes running at\ndifferent nodes of a distributed system. We begin by assuming that\nthe URL frontier is in place and non-empty and defer our\ndescription of the implementation of the URL frontier to Section 20.2.3 .  We follow the progress of a single URL through the cycle of being fetched, passing through various checks and filters, then finally (for continuous crawling) being returned to the URL frontier.\n\n\nA crawler thread begins by taking a URL from the frontier and\nfetching the web page at that URL, generally using the http\nprotocol. The fetched page is then written into a temporary store,\nwhere a number of operations are performed on it. Next, the page is parsed and the text as well as the links in it are extracted. The text (with any tag information - e.g., terms in\nboldface) is passed on to the indexer. Link information including\nanchor text is also passed on to the indexer for use in ranking in\nways that are described in Chapter 21 . In addition, each extracted link\ngoes through a series of tests to determine whether the link should\nbe added to the URL frontier.\n\n\nFirst, the thread tests whether a web page with the same content has already been seen at another URL. The simplest implementation for this would use a simple fingerprint such as a checksum (placed in a store labeled \"Doc FP's\" in Figure 20.1 ). A more sophisticated test would use shingles instead of fingerprints, as described in Chapter 19 .\n\n\nNext, a URL filter is used to determine whether the\nextracted URL should be excluded from the frontier based on one of\nseveral tests. For instance, the crawl may seek to exclude certain\ndomains (say, all .com URLs) - in this case the test would simply\nfilter out the URL if it were from the .com domain. A similar test\ncould be inclusive rather than exclusive. Many hosts on the Web\nplace certain portions of their websites off-limits to crawling,\nunder a standard known as the  Robots Exclusion Protocol , except for the robot called ``searchengine''.\n\n\n\nUser-agent: *\nDisallow: /yoursite/temp/\n\nUser-agent: searchengine\nDisallow:\n\n\nThe robots.txt file must be fetched from a website in order to test whether the URL under consideration passes the robot restrictions, and can therefore be added to the URL frontier. Rather than fetch it afresh for testing on each URL to be added to the frontier, a cache can be used to obtain a recently fetched copy of the file for the host.  This is especially important since many of the links extracted from a page fall within the host from which the page was fetched and therefore can be tested against the host's robots.txt file. Thus, by performing the filtering during the link extraction process, we would have especially high locality in the stream of hosts that we need to test for robots.txt files, leading to high cache hit rates. Unfortunately, this runs afoul of webmasters' politeness expectations. A URL (particularly one referring to a low-quality or rarely changing document) may be in the frontier for days or even weeks. If we were to perform the robots filtering before adding such a URL to the frontier, its robots.txt file could have changed by the time the URL is dequeued from the frontier and fetched. We must consequently perform robots-filtering immediately before attempting to fetch a web page. As it turns out, maintaining a cache of robots.txt files is still highly effective; there is sufficient locality even in the stream of URLs dequeued from the URL frontier.\n\n\nNext, a URL should be  normalized  in the following sense: often the HTML encoding of a link from a web page  indicates the target of that link relative to the page . Thus, there is a relative link encoded thus in the HTML of the page en.wikipedia.org/wiki/Main_Page:\n\n<a href=\"/wiki/Wikipedia:General_disclaimer\"title=\"Wikipedia:Generaldisclaimer\">Disclaimers</a>\n\npoints to the URL\nhttp://en.wikipedia.org/wiki/Wikipedia:General_disclaimer.\n\n\nFinally, the URL is checked for duplicate elimination: if the URL is already in the frontier or (in the case of a non-continuous crawl) already crawled, we do not add it to the frontier. When the URL is added to the frontier, it is assigned a priority based on which it is eventually removed from the frontier for fetching. The details of this priority queuing are in Section 20.2.3 .\n\n\nCertain housekeeping tasks are typically performed by a dedicated\nthread. This thread is generally quiescent except that it wakes up\nonce every few seconds to log crawl progress statistics (URLs\ncrawled, frontier size, etc.), decide whether to terminate the\ncrawl, or (once every few hours of crawling) checkpoint the crawl.\nIn checkpointing, a snapshot of the crawler's state (say, the URL\nfrontier) is committed to disk. In the event of a catastrophic\ncrawler failure, the crawl is restarted from the most recent\ncheckpoint.\n\n\n\n\nSubsections\n\nDistributing the crawler\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: Distributing the crawler\n Up: Crawling\n Previous: Crawling\n    Contents \n    Index\n\n\n© 2008 Cambridge University PressThis is an automatically generated page. In case of formatting errors you may want to look at the PDF edition of the book.\n2009-04-07\n\n\n\n"
}