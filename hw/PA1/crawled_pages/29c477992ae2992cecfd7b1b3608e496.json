{
  "url": "http://nlp.stanford.edu/IR-book/html/htmledition/challenges-in-xml-retrieval-1.html",
  "title": "Challenges in XML retrieval",
  "body": "\n\n\n\n\nChallenges in XML retrieval\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: A vector space model\n Up: XML retrieval\n Previous: Basic XML concepts\n    Contents \n    Index\n\n\n\n\n \n\nChallenges in XML retrieval\n\n\nIn this section, we discuss a number of challenges that make\nstructured retrieval more difficult than unstructured\nretrieval. Recall from page 10  the basic setting we\nassume in structured retrieval:  the collection consists of\nstructured documents and queries are either structured (as\nin Figure 10.3 ) or\nunstructured (e.g., summer holidays). \n\n\nThe first challenge in structured retrieval is\nthat users want us to return parts of documents (i.e., XML\nelements), not entire documents as IR systems usually do in\nunstructured retrieval. If we query Shakespeare's plays for\nMacbeth's castle, should we return the scene, the act or the\nentire play in Figure 10.2 ? In this case, the user is\nprobably looking for\nthe scene. On the other hand, an\notherwise unspecified search for\nMacbeth should return the play of this name, not a\nsubunit.\n\n\nOne criterion for\nselecting the most appropriate part of a document is the\n structured document retrieval principle :\n\nStructured document retrieval principle.\nA system should always retrieve the most specific part of a\ndocument answering the query.\n\n\nThis principle motivates a retrieval strategy that returns\nthe smallest unit that contains the information sought, but\ndoes not go below this level.  However, it can be hard to\nimplement this principle algorithmically.  Consider the\nquery title#\"Macbeth\" applied to Figure 10.2 . The\ntitle of the tragedy,\nMacbeth, and the title of Act I, Scene\nvii, Macbeth's castle, are both good hits because they\ncontain the matching term Macbeth.\nBut in this case, the title of the tragedy,\nthe higher node, is preferred. Deciding which level of the\ntree is right for answering a query is difficult.\n\n\n\n\nFigure 10.5:\nPartitioning an XML document\ninto non-overlapping indexing units.\n\n\n\n\nParallel to the issue of which parts of a document to return\nto the user\nis the issue of which parts of a document to index.\nIn Section 2.1.2 (page ), we discussed the need for a\ndocument unit or  indexing unit  in indexing and retrieval. In unstructured\nretrieval, it is usually clear what the right document unit\nis: files on your desktop, email messages, web pages on the\nweb etc. In structured retrieval, \nthere are a number of  different approaches to defining\nthe indexing unit.\n\n\nOne approach is to group nodes into non-overlapping pseudodocuments\nas shown in Figure 10.5 .  In the example, books,\nchapters and sections have been designated to be indexing\nunits, but without overlap. For example, the leftmost dashed\nindexing unit contains only those parts of the tree\ndominated by book that are not already part of other\nindexing units.  The disadvantage of this approach is that\npseudodocuments may not make sense to the user because\nthey are not coherent units. For instance, the leftmost\nindexing unit\nin Figure 10.5  merges three disparate\nelements, the class, author and\ntitle elements.\n\n\nWe can also use one of the largest elements as the indexing\nunit, for example, the book element  in a collection\nof books or the play element  for Shakespeare's\nworks. We can then postprocess search results to find for each book\nor play\nthe subelement that is the best hit. For example, the query\nMacbeth's castle may return the play Macbeth,\nwhich we can then postprocess to identify act I, scene vii as\nthe best-matching subelement. Unfortunately, this two-stage retrieval\nprocess fails to return the best subelement for many\nqueries because the relevance of a whole book is often\nnot a\ngood predictor of the relevance of small subelements within it.\n\n\nInstead of retrieving large units and identifying\nsubelements (top down), we can also search all leaves,\nselect the most relevant ones and then extend them to\nlarger units in postprocessing (bottom up). For the query Macbeth's castle in\nFigure 10.1 , we would retrieve the title\nMacbeth's castle in the first pass and then decide in a\npostprocessing step whether to return the title, the\nscene, the act or the play. This approach has a similar\nproblem as the last one: The relevance of a leaf element is\noften not a good predictor of the relevance of elements it\nis contained in.\n\n\nThe least restrictive approach is to index all\nelements. This is also problematic.  Many\nXML elements are not meaningful search results, e.g.,\ntypographical elements like\n <b>definitely</b> or an ISBN\nnumber which cannot be interpreted without context.\nAlso, indexing all elements means that search results\nwill be highly redundant.\nFor the query Macbeth's castle and the document in Figure 10.1 ,\nwe would return all of\nthe\nplay, act, scene and title\nelements on the path between the root node and\nMacbeth's castle.\nThe leaf node would then occur four times in the result set,\nonce directly and three times as part of other elements.\nWe call elements that are contained within each other\n  nested .\nReturning redundant nested elements in a list of\nreturned hits\nis not very user-friendly.\n\n\nBecause of the redundancy caused by nested elements\nit is common to restrict the set of\nelements that are eligible to be returned.\nRestriction strategies include:\n\n\ndiscard all small elements\n\ndiscard all element types that users do not look at (this\n  requires a working XML retrieval system that logs this information)\n\ndiscard all element types that assessors generally do not judge to be relevant (if\n  relevance assessments are available)\n\nonly keep element types that a system designer or librarian\n  has deemed to be useful search results\n\n\nIn most of these approaches, result sets will still contain\nnested elements. Thus, we may want to remove some elements\nin a postprocessing step\nto reduce redundancy. Alternatively, we can \ncollapse several nested elements in the results list and use \n highlighting  of query terms to draw the user's attention to the\nrelevant passages. \nIf query terms are highlighted, then scanning a medium-sized\nelement (e.g., a section) takes little more time than\nscanning a small subelement (e.g., a paragraph). Thus, if\nthe section and the paragraph both occur in the results list,\nit is sufficient to show the section. An additional\nadvantage of this approach is that the paragraph is\npresented together with its context\n(i.e., the embedding section). This context may be helpful in\ninterpreting the paragraph (e.g., the source of the\ninformation reported) even if the paragraph on its own\nsatisfies the query.\n\n\nIf the user knows the schema of the collection and\nis able to specify the desired type of element, then the problem of\nredundancy is alleviated as few nested elements have the\nsame type. But as we discussed in the introduction, users\noften don't know what the name of an element in the\ncollection is (Is the Vatican\na country or a city?) or they may not know\nhow to compose structured queries at all.\n\n\nA challenge in XML retrieval related to nesting is that we may need to\ndistinguish different contexts of a term when we compute\nterm statistics for ranking, in particular inverse document\nfrequency ( idf ) statistics as defined in Section 6.2.1 (page ).\nFor example, the term Gates under the\nnode author is unrelated to an occurrence under a\ncontent node like section if used to refer to the\nplural of gate.  It makes little\nsense to compute a single document frequency for\nGates in this example.\n\n\nOne solution is to compute idf for\nXML-contextterm pairs, e.g., to compute different\nidf weights for author#\"Gates\" and\nsection#\"Gates\".  Unfortunately, this scheme will run\ninto sparse data problems - that is, many XML-context\npairs occur too rarely to reliably estimate df (see\nSection 13.2 , page 13.2 , for a\ndiscussion of sparseness).\nA compromise is only to consider the parent node  of the term\nand not the rest of the path from the root to  to\ndistinguish contexts.\nThere are  still conflations of\ncontexts that are harmful in this scheme. For instance, we\ndo not distinguish names of\nauthors and names of corporations if both have the\nparent node name.\nBut most important distinctions, like the\nexample contrast author#\"Gates\" vs. section#\"Gates\", will be respected.\n\n\n\n\nFigure 10.6:\nSchema heterogeneity: intervening nodes and\n  mismatched names.\n\n\n\n\nIn many cases, several different XML schemas occur in a\ncollection since the XML documents in an IR application\noften come from more than one source.  This phenomenon is\ncalled\n schema heterogeneity \nor\n schema diversity  and\npresents yet\nanother challenge.  \nAs illustrated in\nFigure 10.6  comparable elements  may have different\nnames: creator in  vs. author in\n. In other cases,\nthe structural\norganization of the schemas may be different: Author names are\ndirect descendants of the node author in ,\nbut there are the intervening nodes firstname and\nlastname in . If we employ strict matching of\ntrees, then  will retrieve neither  nor \nalthough both documents are relevant.\nSome form\nof approximate matching of element names in combination with\nsemi-automatic matching of different document structures can\nhelp here. Human editing of correspondences of elements in\ndifferent schemas will usually do better than automatic\nmethods.\n\n\nSchema heterogeneity is one reason for query-document\nmismatches like  and . Another reason is\nthat users often are not familiar with the element names\nand the structure of the schemas of collections\nthey search as mentioned.  This poses a challenge for interface design in\nXML retrieval.  Ideally, the user interface should expose\nthe tree structure of the collection and allow users to\nspecify the elements they are querying. If we take this\napproach, then\ndesigning the\nquery interface in structured retrieval is more complex than a search box for\nkeyword queries in unstructured retrieval.\n\n\nWe can also support the user by interpreting all\nparent-child relationships in queries as descendant\nrelationships with any number of intervening nodes\nallowed. We call such queries\n extended queries . The tree in Figure 10.3  and  in Figure 10.6  are  examples of\nextended queries. We show edges that are interpreted as\ndescendant relationships as dashed arrows. In , a\ndashed arrow connects book and\nGates.\nAs a pseudo-XPath notation for ,\nwe adopt\nbook//#\"Gates\": a book that somewhere in its structure\ncontains the word Gates where the path from the\nbook node to Gates can be arbitrarily long.\nThe pseudo-XPath notation for the extended query that in addition\nspecifies that Gates occurs\nin a section\nof the book\nis book//section//#\"Gates\".\nIt is convenient for users to be able to\nissue such extended queries without having to specify the exact\nstructural configuration in which a query term should occur\n- either because they do not care about the exact\nconfiguration or because they do not know enough about the\nschema of the collection to be able to specify it.\n\n\n\n\nFigure 10.7:\nA structural mismatch between two queries and a document.\n\n\n\n\nIn Figure 10.7 , the user is looking for a\nchapter entitled FFT (). Suppose there is no\nsuch chapter in the collection, but that there are\nreferences to books on FFT (). A reference to a book on\nFFT is not exactly what the user is looking for, but it is\nbetter than returning nothing. Extended queries do not\nhelp here. The extended query  also returns nothing. This is a case\nwhere we may want to interpret the structural constraints\nspecified in the query as hints as opposed to as strict\nconditions. As we will discuss in\nSection 10.4 , users prefer a relaxed interpretation of\nstructural constraints: Elements that do not meet structural\nconstraints perfectly should be ranked lower, but they\nshould not be omitted from search results.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: A vector space model\n Up: XML retrieval\n Previous: Basic XML concepts\n    Contents \n    Index\n\n\n© 2008 Cambridge University PressThis is an automatically generated page. In case of formatting errors you may want to look at the PDF edition of the book.\n2009-04-07\n\n\n\n"
}