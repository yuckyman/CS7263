{
  "url": "http://nlp.stanford.edu/IR-book/html/htmledition/other-types-of-indexes-1.html",
  "title": "Other types of indexes",
  "body": "\n\n\n\n\nOther types of indexes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: References and further reading\n Up: Index construction\n Previous: Dynamic indexing\n    Contents \n    Index\n\n\n\n\n \n\nOther types of indexes\n  This chapter only describes\nconstruction of nonpositional indexes. Except for the much\nlarger data volume we need to accommodate, the \nmain\ndifference for positional indexes is that (termID, docID,\n(position1, position2, ...)) triples, instead of (termID,\ndocID) pairs have to be processed \nand that tokens and postings\ncontain positional information in addition to  docIDs. With this\nchange, the algorithms discussed here can all be applied to\npositional indexes.\n\n\n  In the indexes we have\nconsidered so far, postings lists are ordered with respect\nto docID. As we\nsee in Chapter 5, this is advantageous for\ncompression - instead of docIDs we can compress smaller\ngaps between IDs, thus reducing space requirements\nfor the index. However, this structure for the index is not\noptimal when we build  ranked  (Chapters 6 7 ) - as\nopposed to Boolean -  retrieval systems .  In ranked\nretrieval, postings are often ordered according to weight or\n impact , with the highest-weighted postings\noccurring first.  With this organization, scanning of long\npostings lists during query processing can usually be\nterminated early when weights have become so small that any\nfurther documents can be predicted to be of low similarity\nto the query (see Chapter 6 ). In a docID-sorted index,\nnew documents are always inserted at the end of postings\nlists. In an impact-sorted index impactordered, the\ninsertion can occur anywhere, thus complicating the update of the inverted\nindex.\n\n\n Security  is an important consideration for retrieval\nsystems in corporations. \nA low-level employee should not be able to find\nthe salary roster of the\ncorporation, but authorized managers need to be able to\nsearch for it.\nUsers' results lists must not contain documents they\nare barred from opening; the very existence of a\ndocument can be sensitive information.\n\n\n\n\nFigure:\nA user-document matrix for \naccess control lists. Element \nis 1 if user  has access to document  and 0\notherwise. During query processing, a user's access postings list is intersected with\nthe results list returned by the text part of the index.\n\n\n\n\n\nUser authorization is often mediated through  access\ncontrol lists  or ACLs. ACLs can be dealt with in an\ninformation retrieval system\nby representing each document\nas the set\nof users that can access them (Figure 4.8 ) and then\ninverting the resulting user-document matrix. The inverted\nACL index has, for each user, a ``postings list'' of\ndocuments they can access - the user's access list. Search\nresults are then intersected with this list. However, such\nan index is difficult to maintain when access permissions\nchange - we discussed these difficulties in the context of\nincremental indexing for regular postings lists in\nSection 4.5. It also requires the processing of very long postings\nlists for users with access to large document subsets. User\nmembership is therefore often verified by retrieving access\ninformation directly\nfrom the file system at query time -\neven though this slows down retrieval.\n\n\nWe discussed \nindexes for storing and retrieving terms (as opposed to\ndocuments) in Chapter 3 .\n\n\nExercises.\n\nCan spelling correction compromise document-level\nsecurity? Consider the case where a spelling correction is\nbased on documents to which the user does not have access.\n\n\n\n\n\nExercises.\n\nTotal index construction time in\nblocked sort-based indexing is broken down in Table 4.3.\nFill out the time column of the table for Reuters-RCV1\nassuming a system with the parameters given in Table 4.1 .\n \n\n\n\n\n\n\nTable:\n The five steps in constructing an\nindex for Reuters-RCV1 in blocked sort-based indexing. Line numbers refer to Figure 4.2 .\n  \nStep\nTime\n \n 1\nreading of collection (line 4)\n \n \n 2\n10 initial sorts of  records each (line 5)\n \n \n 3\nwriting of 10 blocks (line 6)\n \n \n 4\ntotal disk transfer time for merging (line 7)\n \n \n 5\ntime of actual merging (line 7)\n \n \n  \ntotal\n \n \n\n\n\n\n\n\n\n\n\nTable 4.4:\nCollection statistics for a large collection.\n Symbol\nStatistic\nValue\n \n \n# documents\n1,000,000,000\n \n \n# tokens per document\n1000\n \n \n# distinct terms\n44,000,000\n\n\n \n\n \n\n\n\n\nRepeat Exercise 4.6  for the larger\ncollection in Table 4.4 . Choose a block size\nthat is realistic for current technology\n(remember that a block\nshould easily fit into main memory). \nHow many blocks do you need?\n\n\n\nAssume that we have a collection of modest size\nwhose index can be constructed with the simple in-memory\nindexing algorithm\nin Figure 1.4 (page ). For this collection,\ncompare memory, disk and time requirements of\nthe simple algorithm in Figure 1.4  and \nblocked sort-based indexing.\n\n\n\n   \nAssume that machines in MapReduce have 100 GB of disk\nspace each. Assume further that the postings list of the\nterm the has a size of 200 GB. Then the MapReduce\nalgorithm as described cannot be run to construct the index.\nHow would you modify\nMapReduce so that it can handle this case?\n\n\n\n   For optimal load\nbalancing, the inverters in MapReduce must get segmented\npostings files of similar sizes. For a new collection, the\ndistribution of key-value pairs may not be known in\nadvance. How would you solve this problem?\n\n\n\nApply MapReduce to the problem of counting how\noften each term occurs in a set of files. Specify map and\nreduce operations for this task. Write down an example\nalong the lines of Figure 4.6 .\n\n\n\nWe claimed (on page 4.5 ) that an\nauxiliary index can impair the quality of collection statistics.\nAn example is the\nterm weighting method  idf ,\nwhich is defined as \n\nwhere  is the total number of documents and  is the\nnumber of documents that term  occurs in\nidf. Show that\neven a small auxiliary index can cause significant error in idf\nwhen it is computed on the main index only. Consider a\nrare term that suddenly occurs frequently (e.g.,\nFlossie as in Tropical Storm Flossie).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: References and further reading\n Up: Index construction\n Previous: Dynamic indexing\n    Contents \n    Index\n\n\n© 2008 Cambridge University PressThis is an automatically generated page. In case of formatting errors you may want to look at the PDF edition of the book.\n2009-04-07\n\n\n\n"
}