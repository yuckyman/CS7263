{
  "url": "http://nlp.stanford.edu/IR-book/html/htmledition/distributing-the-crawler-1.html",
  "title": "Distributing the crawler",
  "body": "\n\n\n\n\nDistributing the crawler\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: DNS resolution\n Up: Crawler architecture\n Previous: Crawler architecture\n    Contents \n    Index\n\n\n\n\nDistributing the crawler\n\n\nWe have mentioned that the threads in a crawler could run under different processes, each at a different node of a distributed crawling system. Such distribution is essential for scaling; it can also be of use in a geographically distributed crawler system where each node crawls hosts ``near'' it. Partitioning the hosts being crawled amongst the crawler nodes can be done by a hash function, or by some more specifically tailored policy. For instance, we may locate a crawler node in Europe to focus on European domains, although this is not dependable for several reasons - the routes that packets take through the internet do not always reflect geographic proximity, and in any case the domain of a host does not always reflect its physical location.\n\n\nHow do the various nodes of a distributed crawler communicate and share URLs? The idea is to replicate the flow of Figure 20.1  at each node, with one essential difference: following the URL filter, we use a host splitter to dispatch each surviving URL to the crawler node responsible for the URL; thus the set of hosts being crawled is partitioned among the nodes. This modified flow is shown in Figure 20.2 . The output of the host splitter goes into the Duplicate URL Eliminator block of each other node in the distributed system.\n\n\nThe ``Content Seen?'' module in the distributed architecture of Figure 20.2  is, however, complicated by several factors:\n\n\nUnlike the URL frontier and the duplicate\n  elimination module, document fingerprints/shingles cannot\n  be partitioned based on host name. There is nothing\n  preventing the same (or highly similar) content from\n  appearing on different web servers. Consequently, the set\n   of fingerprints/shingles must be partitioned across the nodes based on some property of the fingerprint/shingle (say by taking the fingerprint modulo the number of nodes). The result of this locality-mismatch is that most ``Content Seen?'' tests result in a remote procedure call (although it is possible to batch lookup requests).\n\nThere is very little locality in the stream of document fingerprints/shingles. Thus, caching popular fingerprints does not help (since there are no popular fingerprints).\n\nDocuments change over time and so, in the context of continuous crawling, we must be able to delete their outdated fingerprints/shingles from the content-seen set(s). In order to do so, it is necessary to save the fingerprint/shingle of the document in the URL frontier, along with the URL itself.\n\n\n\n\nFigure 20.2:\nDistributing the basic crawl architecture.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: DNS resolution\n Up: Crawler architecture\n Previous: Crawler architecture\n    Contents \n    Index\n\n\n© 2008 Cambridge University PressThis is an automatically generated page. In case of formatting errors you may want to look at the PDF edition of the book.\n2009-04-07\n\n\n\n"
}