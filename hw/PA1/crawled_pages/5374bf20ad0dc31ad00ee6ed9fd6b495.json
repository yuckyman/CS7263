{
  "url": "http://nlp.stanford.edu/IR-book/html/htmledition/hardware-basics-1.html",
  "title": "Hardware basics",
  "body": "\n\n\n\n\nHardware basics\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: Blocked sort-based indexing\n Up: Index construction\n Previous: Index construction\n    Contents \n    Index\n\n\n\n\n \n\nHardware basics\n\n\n\n\n\n\nTable 4.1:\nTypical system parameters\nin 2007.\nThe seek time is the time needed to position the disk head in\na new position. The transfer time per byte is the rate\nof transfer from disk to memory when the head is in the right position. \n\n Symbol\nStatistic\nValue\n \n \naverage seek  time\n5 ms  \n  s\n \n \ntransfer time per byte\n0.02 s  \n s\n \n  \nprocessor's clock rate\n\n\n \n \nlowlevel operation\n \n \n  \n    (e.g., compare & swap a word)\n0.01 s \n\n s\n \n  \nsize of main memory\nseveral GB\n \n  \nsize of disk space\n1 TB or more\n \n\n \n\n\n\nWhen building an information retrieval (IR)\nsystem, many decisions are based on the characteristics of the computer\nhardware on which the system runs. We therefore begin\nthis chapter with a brief review of computer\nhardware.\nPerformance characteristics\ntypical of systems in 2007 are shown in Table 4.1 .\nA list of hardware basics that we need in\nthis book to motivate IR system design follows.\n\n\nAccess to data in memory is much faster than access to\ndata on disk. It takes a few clock cycles (perhaps\n\n seconds) to access a byte in memory, but\nmuch longer\nto transfer it from disk\n(about\n\n seconds). Consequently, we\nwant to keep as much data as possible in memory, especially\nthose data that we need to access frequently.\nWe call the technique of keeping frequently used disk data\nin main memory  caching .\n\n\n\nWhen doing a disk read or write, it takes a while for\nthe disk head to move to the part of the disk where the data\nare located. This time is called the \n seek time  and it\naverages 5 ms for typical disks. \nNo data are being transferred during the seek.\nTo maximize data transfer\nrates, chunks of data that will be read together should\ntherefore be stored contiguously on disk.  For example,\nusing the numbers in Table 4.1  it may take as\nlittle as 0.2 seconds to transfer 10 megabytes (MB) from disk to memory\nif it is stored as one chunk, but up to\n\n seconds if it is\nstored in 100 noncontiguous chunks because we need to\nmove the disk head up to 100 times.\n\n\n\nOperating systems generally read and write entire\n  blocks. Thus, reading\n  a single byte from disk can take as much time as reading the\n  entire block. Block sizes of 8, 16, 32, and 64 kilobytes (KB)\n  are common. We call the part of main memory where a block being\n  read or written is stored a  buffer .\n\n\n\nData transfers from disk to memory are handled by the\n  system bus, not by the processor. This means that the\nprocessor is available to process data during disk I/O.\nWe can exploit this fact to speed up data transfers\nby storing compressed data on disk. Assuming an efficient\n  decompression algorithm, the total time of\n  reading and then decompressing compressed data is usually less\n  than reading uncompressed data.\n\n\n\nServers used in IR systems\ntypically have \nseveral gigabytes (GB) of main\n  memory, sometimes tens of GB. Available disk space is\n  several orders of magnitude larger.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: Blocked sort-based indexing\n Up: Index construction\n Previous: Index construction\n    Contents \n    Index\n\n\n© 2008 Cambridge University PressThis is an automatically generated page. In case of formatting errors you may want to look at the PDF edition of the book.\n2009-04-07\n\n\n\n"
}