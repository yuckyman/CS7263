{
  "url": "http://nlp.stanford.edu/IR-book/html/htmledition/processing-boolean-queries-1.html",
  "title": "Processing Boolean queries",
  "body": "\n\n\n\n\nProcessing Boolean queries\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: The extended Boolean model\n Up: Boolean retrieval\n Previous: A first take at\n    Contents \n    Index\n\n\n\n \n \n\nProcessing Boolean queries\n\n\nHow do we process a query using an inverted index and the basic\nBoolean retrieval model?\nConsider processing the\n simple conjunctive query :\n\n\n\nover the inverted index partially shown in\nFigure 1.3 (page ).  We:\n\n\nLocate Brutus in the Dictionary\n\nRetrieve its postings\n\nLocate Calpurnia in the Dictionary\n\nRetrieve its postings\n\nIntersect the two postings lists, as shown in Figure 1.5 .\n\n\nThe  intersection   is the\ncrucial one: we\nneed to efficiently\nintersect postings lists so as to be able to quickly find documents that\ncontain both terms.  (This operation is sometimes referred to as\n merging  postings lists: this\nslightly counterintuitive name reflects using the term  merge algorithm  for a general family of algorithms that\ncombine multiple sorted lists by interleaved advancing of pointers through\neach; here we are merging the lists with a\nlogical AND operation.)\n\n\n\n\nFigure:\nIntersecting the postings lists for Brutus and\n  Calpurnia from Figure 1.3 .\n\n\n\n\n\n\nFigure 1.6:\nAlgorithm for the intersection of two postings lists  and .\n\n\n\n\nThere is a simple and effective method of intersecting postings lists\nusing the merge algorithm (see Figure 1.6 ): we maintain\npointers into both lists and walk through the two postings lists\nsimultaneously, in time linear in the total number of postings entries.\nAt each step, we compare the docID pointed to by both pointers.  If they\nare the same, we put that docID in the results list, and advance both\npointers.  Otherwise we\nadvance the pointer pointing to the smaller docID.  If the lengths of\nthe postings lists are  and , the intersection takes \noperations.\nFormally, the complexity of querying is ,where  is the number of documents in the collection.Our indexing methods gain us just a constant, not a\ndifference in  time complexity compared to a linear\nscan, but in practice the constant is huge.\nTo use this algorithm, it is crucial that\npostings be sorted by a single global ordering.  Using a numeric sort by\ndocID is one simple way to achieve this.\n\n\nWe can extend the intersection operation to process more complicated queries\nlike:\n\n\n\n Query optimization  is the process of\nselecting how to organize the work\nof answering a query so that the least total amount of work needs to be\ndone by the system.  A major element of this for Boolean queries is the\norder in which postings lists are accessed.  What is the best order for\nquery processing?\nConsider a query that is an AND of  terms, for instance:\n\n\n\nFor each of the  terms, we need to get its postings, then AND them\ntogether.  The standard heuristic is to process terms in order of\nincreasing document frequency:\nif we start by intersecting the two smallest postings lists, then all\nintermediate results must be no bigger than the smallest postings list,\nand we are therefore likely to do the least amount of\ntotal work. So, for the postings lists in Figure 1.3 (page ),\nwe execute the above query as:\n\n\n\nThis is a first justification for keeping\nthe frequency of terms in the dictionary: it allows us to make this\nordering decision\nbased on in-memory data before accessing any postings list.\n\n\nConsider now the optimization of more general queries, such as:\n\n\n\nAs before, we will get the frequencies for all terms, and we can then\n(conservatively) estimate the size of each OR by the sum of the\nfrequencies of its disjuncts.  We can then process the query in\nincreasing order of the size of each disjunctive term.\n\n\n\n\nFigure 1.7:\nAlgorithm for conjunctive queries that returns the set of documents containing each term in the input list of terms.\n\n\n\n\nFor arbitrary Boolean queries, we have to evaluate and temporarily store\nthe answers\nfor intermediate expressions in a complex expression.  However, in many\ncircumstances, either because of the nature of the query language, or\njust because this is the most common type of query that users submit, a\nquery is purely conjunctive.  In this case, rather than viewing\nmerging postings lists as a function with two inputs and a distinct\noutput, it is more efficient\nto intersect each retrieved postings list with the current\nintermediate result in memory, where we initialize the intermediate\nresult by loading the postings\nlist of the\nleast frequent term.  This algorithm is shown in\nFigure 1.7 . The intersection operation is then\nasymmetric: the intermediate results list is in memory while the list it\nis being intersected with is being read from disk.  Moreover the\nintermediate results list is always at least as\nshort as the other list, and in many cases it is orders of\nmagnitude shorter.\nThe postings intersection can still be done by the algorithm in\nFigure 1.6 , but when the difference between the list\nlengths is very large, opportunities to use\nalternative techniques open up.  The intersection can be\ncalculated in place by destructively modifying or marking invalid items\nin the intermediate\nresults list.  Or the intersection can be done as\na sequence of binary searches in the long\npostings lists for each posting\nin the intermediate results list.  Another possibility is to store the\nlong postings list as a hashtable, so that membership of an intermediate\nresult item can\nbe calculated in constant rather than linear or log time.\nHowever, such alternative techniques are difficult to combine with\npostings list compression of the sort discussed in Chapter 5 .\nMoreover, standard postings list intersection operations remain\nnecessary when both terms of a query are very common.\n\n\nExercises.\n\nFor the queries below, can we still run through the\nintersection in time , where  and  are the lengths of the\npostings lists for Brutus and Caesar?\nIf not, what can we achieve?\n\n\nBrutus and not Caesar\n\nBrutus or not Caesar\n\n\n\n\nExtend the postings merge algorithm to arbitrary Boolean\nquery formulas.\nWhat is its time complexity?  For instance, consider:\n\nc.\n(Brutus OR Caesar) AND NOT\n   (Antony OR Cleopatra)\n\n\nCan we always merge in linear time? Linear in what?\nCan we do better than this?\n\n\n\nWe can use distributive laws for and and\nor to rewrite queries.\n\n\nShow how to rewrite the query in Exercise 1.3  into\ndisjunctive normal form using the\ndistributive laws.\n\nWould the resulting query be more or less efficiently\nevaluated than the original form of this query?\n\nIs this result true in\ngeneral or does it depend on the words and the contents of the document\ncollection?\n\n\n\n\nRecommend a query processing order for\n\nd.\n(tangerine OR trees) AND (marmalade\n   OR skies) AND\n   (kaleidoscope OR eyes)\n\n\ngiven the following postings list sizes:\n\n\nTerm\nPostings size\n\neyes\n213312\n\nkaleidoscope\n87009\n\nmarmalade\n107913\n\nskies\n271658\n\ntangerine\n46653\n\ntrees\n316812\n\n\n\n\n\nIf the query is:\n\ne.\nfriends AND romans AND (NOT\n   countrymen)\n\n\nhow could we use the frequency of countrymen in evaluating the\nbest query evaluation order?  In particular, propose a way of handling\nnegation in determining the order of query processing.\n\n\n\nFor a conjunctive query, is processing postings lists in order\nof size guaranteed to be optimal? Explain why it is, or give an example\nwhere it isn't.\n\n\n\nWrite out a postings merge algorithm, in the style of\nFigure 1.6 (page ), for\nan  OR  query.\n\n\n\nHow should the Boolean query  AND NOT  be handled?\nWhy is naive evaluation of this query normally very expensive?  Write\nout a postings merge algorithm that evaluates this query efficiently.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Next: The extended Boolean model\n Up: Boolean retrieval\n Previous: A first take at\n    Contents \n    Index\n\n\n© 2008 Cambridge University PressThis is an automatically generated page. In case of formatting errors you may want to look at the PDF edition of the book.\n2009-04-07\n\n\n\n"
}